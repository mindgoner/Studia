{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "6b90c6ca-9316-494f-b741-8f3692e5f4d6",
   "metadata": {},
   "source": [
    "# Zajęcie 5. Bezpieczeństwo danych"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "06e571e5-8e46-4dd2-83c9-4abfbe0942b0",
   "metadata": {},
   "source": [
    "## Szyfrowanie danych (Fernet, AES)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "ef07dc05-53dc-446f-a3b9-e9b939a19154",
   "metadata": {},
   "outputs": [],
   "source": [
    "from cryptography.fernet import Fernet\n",
    "import pandas as pd\n",
    "\n",
    "key = Fernet.generate_key()\n",
    "cipher = Fernet(key)\n",
    "\n",
    "df = pd.read_csv(\"dane_zaj1/dane_pacjentow_demo.csv\")\n",
    "df[\"diagnosis_enc\"] = df[\"visit_date\"].apply(\n",
    "    lambda x: cipher.encrypt(x.encode()).decode()\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "823e66f9-3eff-459e-8763-d05c2c0e089c",
   "metadata": {},
   "source": [
    "## Haszowanie (SHA-256)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b77dca0a-99e8-4565-8b48-bd3205ccfe5c",
   "metadata": {},
   "outputs": [],
   "source": [
    "from cryptography.fernet import Fernet\n",
    "import pandas as pd\n",
    "\n",
    "key = Fernet.generate_key()\n",
    "cipher = Fernet(key)\n",
    "\n",
    "df = pd.read_csv(\"dane_zaj1/dane_pacjentow_demo.csv\")\n",
    "df[\"diagnosis_enc\"] = df[\"visit_date\"].apply(\n",
    "    lambda x: cipher.encrypt(x.encode()).decode()\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "91bd70f0-5b5b-44ed-b59e-1d72d67f7fa9",
   "metadata": {},
   "source": [
    "## Pseudonimizacja kolumny"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "7ed28bc8-274c-420b-a991-6edc94fe9494",
   "metadata": {},
   "outputs": [],
   "source": [
    "import uuid\n",
    "df[\"patient_id\"] = [str(uuid.uuid4()) for _ in range(len(df))]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2267c700-f650-4c0e-89a1-fc3d4ab0ed87",
   "metadata": {},
   "source": [
    "# ============================================\n",
    "# Bezpieczeństwo danych medycznych – Etapy 2–5\n",
    "# ============================================"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "e3efd5b3-a1a1-4ee5-bfad-0d7a5867a030",
   "metadata": {},
   "outputs": [],
   "source": [
    "# IMPORTY\n",
    "import os\n",
    "import uuid\n",
    "import hashlib\n",
    "from datetime import datetime\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "from cryptography.fernet import Fernet\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.linear_model import LogisticRegression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "d0c32a7a-28d6-45d6-827d-ba9504ed9fcc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Podgląd danych:\n",
      "   age sex   bmi  systolic_bp  diastolic_bp  hypertension     diagnosis  \\\n",
      "0   86   F  28.0          174            97             1  Hypertension   \n",
      "1   63   M  17.9          162            82             1  Hypertension   \n",
      "2   67   F  18.4          146            73             1  Hypertension   \n",
      "3   82   M  31.3          167           102             1  Hypertension   \n",
      "4   59   M  25.4          171            89             1  Hypertension   \n",
      "\n",
      "                                       diagnosis_enc  \n",
      "0  gAAAAABpKq4KK2X9U8OILr3L86_ptLbFGjDNg2JRFH4Hyy...  \n",
      "1  gAAAAABpKq4KiuJ1OiCeGFoK_nAIpQZEOKkn8RPwedh3lp...  \n",
      "2  gAAAAABpKq4KutLh46htAQWNzgr4jbO0oaWQ44r4nAO6iX...  \n",
      "3  gAAAAABpKq4KDpCY0ONDu6yixEk_jtbWZUhZtGq4qQupYb...  \n",
      "4  gAAAAABpKq4KxuGauV7QdLo9R2j8VlB5Ba9EayLZJnxY5V...  \n"
     ]
    }
   ],
   "source": [
    "# -------------------------------------------------\n",
    "# Przygotowanie danych (skrót Etapu 1 – dla kontekstu)\n",
    "# -------------------------------------------------\n",
    "PATH = \"dane_pacjentow_demo.csv\"\n",
    "\n",
    "if os.path.exists(PATH):\n",
    "    df = pd.read_csv(PATH)\n",
    "else:\n",
    "    # Demo: generujemy prosty zbiór danych, jeśli plik nie istnieje\n",
    "    rng = np.random.default_rng(7)\n",
    "    N = 200\n",
    "    age = rng.integers(18, 90, size=N)\n",
    "    sex = rng.choice([\"F\", \"M\"], size=N)\n",
    "    height = rng.normal(170, 10, size=N).clip(140, 200)\n",
    "    weight = rng.normal(75, 15, size=N).clip(40, 160)\n",
    "    bmi = weight / (height/100)**2\n",
    "    sbp = (100 + 0.5*age + 1.2*bmi + (sex==\"M\")*5 + rng.normal(0,10,N)).round()\n",
    "    dbp = (60 + 0.2*age + 0.6*bmi + (sex==\"M\")*3 + rng.normal(0,6,N)).round()\n",
    "    hypertension = ((sbp >= 140) | (dbp >= 90)).astype(int)\n",
    "\n",
    "    df = pd.DataFrame({\n",
    "        \"age\": age,\n",
    "        \"sex\": sex,\n",
    "        \"bmi\": bmi.round(1),\n",
    "        \"systolic_bp\": sbp.astype(int),\n",
    "        \"diastolic_bp\": dbp.astype(int),\n",
    "        \"hypertension\": hypertension\n",
    "    })\n",
    "    df.to_csv(PATH, index=False)\n",
    "\n",
    "print(\"Podgląd danych:\")\n",
    "print(df.head())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "b0c9fd6f-4d64-478b-981c-120d2eaf7c49",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "[Etap 2.1] Klucz szyfrujący wygenerowany.\n",
      "\n",
      "[Etap 2.1] Przykład zaszyfrowanej diagnozy:\n",
      "      diagnosis                                      diagnosis_enc\n",
      "0  Hypertension  gAAAAABpKrtBHRu8MVG4VV5b3ma50b5WbtdphM9bAEFg0M...\n",
      "1  Hypertension  gAAAAABpKrtBTs3FSWhkEhyhWAGKAnw0W22l07JWicHFwy...\n",
      "2  Hypertension  gAAAAABpKrtBHsll2_NDgFaIApUeud6R9wD-O0tw2ej7Lb...\n",
      "3  Hypertension  gAAAAABpKrtBDzZn_jlNFBguHvOdjJNSVLMEbYgwd9nHv8...\n",
      "4  Hypertension  gAAAAABpKrtBJMX0b5n4oxDeVpoM1gXQ4vSYjiAoDosQHz...\n",
      "\n",
      "[Etap 2.2] SHA-256 pliku danych:\n",
      "a3f56260aa026939764baa70de7e66f8512ee7a47a01e152b088d00ff56020dd\n"
     ]
    }
   ],
   "source": [
    "# ============================================\n",
    "# ETAP 2: SZYFROWANIE I INTEGRALNOŚĆ DANYCH\n",
    "# ============================================\n",
    "\n",
    "# --- 2.1 Szyfrowanie wybranych kolumn (np. diagnoza / etykieta) ---\n",
    "\n",
    "# Dla przykładu tworzymy kolumnę 'diagnosis' na podstawie 'hypertension'\n",
    "if \"diagnosis\" not in df.columns:\n",
    "    df[\"diagnosis\"] = df[\"hypertension\"].map({1: \"Hypertension\", 0: \"Normal\"})\n",
    "\n",
    "# Generujemy klucz symetryczny (Fernet oparty na AES)\n",
    "key = Fernet.generate_key()\n",
    "cipher = Fernet(key)\n",
    "print(\"\\n[Etap 2.1] Klucz szyfrujący wygenerowany.\")\n",
    "\n",
    "# Szyfrujemy kolumnę 'diagnosis' do nowej kolumny 'diagnosis_enc'\n",
    "df[\"diagnosis_enc\"] = df[\"diagnosis\"].apply(\n",
    "    lambda x: cipher.encrypt(x.encode(\"utf-8\")).decode(\"utf-8\")\n",
    ")\n",
    "print(\"\\n[Etap 2.1] Przykład zaszyfrowanej diagnozy:\")\n",
    "print(df[[\"diagnosis\", \"diagnosis_enc\"]].head())\n",
    "\n",
    "# --- 2.2 Hashowanie pliku z danymi (integralność) ---\n",
    "\n",
    "def compute_file_hash(path: str, algo: str = \"sha256\") -> str:\n",
    "    \"\"\"Zwraca skrót kryptograficzny pliku.\"\"\"\n",
    "    h = hashlib.new(algo)\n",
    "    with open(path, \"rb\") as f:\n",
    "        for chunk in iter(lambda: f.read(4096), b\"\"):\n",
    "            h.update(chunk)\n",
    "    return h.hexdigest()\n",
    "\n",
    "# Zapisujemy aktualny plik i liczymy hash\n",
    "df.to_csv(PATH, index=False)\n",
    "original_hash = compute_file_hash(PATH, \"sha256\")\n",
    "print(\"\\n[Etap 2.2] SHA-256 pliku danych:\")\n",
    "print(original_hash)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "768ae3e6-4b74-4457-9d56-6d784305efe3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "[Etap 3.1] Pseudonimizacja – przykładowe identyfikatory:\n",
      "                             patient_id\n",
      "0  3b059fba-94ce-4c5e-9886-b739d38cc1a4\n",
      "1  dbef56da-850c-4ea8-84e9-4200023dc57d\n",
      "2  9c2d64ff-c813-4262-8b22-f41722085da0\n",
      "3  2df21907-894b-4a30-aea2-1cf536a45797\n",
      "4  63a40b0b-8dad-4a2e-a339-1e81f05d79b1\n",
      "\n",
      "[Etap 3.2] Przykład anonimizacji (grupy wiekowe zamiast surowej wartości):\n",
      "  age_group   bmi  systolic_bp  diastolic_bp\n",
      "0      >=70  28.0          174            97\n",
      "1     50-69  17.9          162            82\n",
      "2     50-69  18.4          146            73\n",
      "3      >=70  31.3          167           102\n",
      "4     50-69  25.4          171            89\n"
     ]
    }
   ],
   "source": [
    "# ============================================\n",
    "# ETAP 3: PSEUDONIMIZACJA I ANONIMIZACJA\n",
    "# ============================================\n",
    "\n",
    "# --- 3.1 Pseudonimizacja: sztuczny identyfikator pacjenta ---\n",
    "\n",
    "if \"patient_id\" not in df.columns:\n",
    "    df[\"patient_id\"] = [str(uuid.uuid4()) for _ in range(len(df))]\n",
    "print(\"\\n[Etap 3.1] Pseudonimizacja – przykładowe identyfikatory:\")\n",
    "print(df[[\"patient_id\"]].head())\n",
    "\n",
    "# --- 3.2 Anonimizacja: tworzymy grupy wiekowe i usuwamy potencjalne identyfikatory ---\n",
    "\n",
    "def age_to_group(age):\n",
    "    if age < 30:\n",
    "        return \"<30\"\n",
    "    elif age < 50:\n",
    "        return \"30-49\"\n",
    "    elif age < 70:\n",
    "        return \"50-69\"\n",
    "    else:\n",
    "        return \">=70\"\n",
    "\n",
    "df[\"age_group\"] = df[\"age\"].apply(age_to_group)\n",
    "\n",
    "# Załóżmy, że 'age' to potencjalnie zbyt szczegółowa cecha – usuwamy ją po generalizacji\n",
    "df_anonym = df.drop(columns=[\"age\"])  # w realnym systemie usunęlibyśmy też imię/nazwisko, PESEL itd.\n",
    "\n",
    "print(\"\\n[Etap 3.2] Przykład anonimizacji (grupy wiekowe zamiast surowej wartości):\")\n",
    "print(df_anonym[[\"age_group\", \"bmi\", \"systolic_bp\", \"diastolic_bp\"]].head())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "9b66bf40-3acb-4a07-b048-c595c105843b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "[Etap 4] Przykładowe widoki danych dla różnych ról:\n",
      "\n",
      "Rola admin (pierwsze 3 wiersze):\n",
      "  sex   bmi  systolic_bp  diastolic_bp  hypertension     diagnosis  \\\n",
      "0   F  28.0          174            97             1  Hypertension   \n",
      "1   M  17.9          162            82             1  Hypertension   \n",
      "2   F  18.4          146            73             1  Hypertension   \n",
      "\n",
      "                                       diagnosis_enc  \\\n",
      "0  gAAAAABpKrtBHRu8MVG4VV5b3ma50b5WbtdphM9bAEFg0M...   \n",
      "1  gAAAAABpKrtBTs3FSWhkEhyhWAGKAnw0W22l07JWicHFwy...   \n",
      "2  gAAAAABpKrtBHsll2_NDgFaIApUeud6R9wD-O0tw2ej7Lb...   \n",
      "\n",
      "                             patient_id age_group  \n",
      "0  3b059fba-94ce-4c5e-9886-b739d38cc1a4      >=70  \n",
      "1  dbef56da-850c-4ea8-84e9-4200023dc57d     50-69  \n",
      "2  9c2d64ff-c813-4262-8b22-f41722085da0     50-69  \n",
      "\n",
      "Rola doctor (pierwsze 3 wiersze):\n",
      "                             patient_id age_group   bmi  systolic_bp  \\\n",
      "0  3b059fba-94ce-4c5e-9886-b739d38cc1a4      >=70  28.0          174   \n",
      "1  dbef56da-850c-4ea8-84e9-4200023dc57d     50-69  17.9          162   \n",
      "2  9c2d64ff-c813-4262-8b22-f41722085da0     50-69  18.4          146   \n",
      "\n",
      "   diastolic_bp  hypertension     diagnosis  \n",
      "0            97             1  Hypertension  \n",
      "1            82             1  Hypertension  \n",
      "2            73             1  Hypertension  \n",
      "\n",
      "Rola analyst (pierwsze 3 wiersze):\n",
      "  age_group   bmi  systolic_bp  diastolic_bp  hypertension\n",
      "0      >=70  28.0          174            97             1\n",
      "1     50-69  17.9          162            82             1\n",
      "2     50-69  18.4          146            73             1\n",
      "\n",
      "[Etap 4] Log audytu:\n",
      "{'time': '2025-11-29T10:27:03', 'user': 'alice_admin', 'role': 'admin', 'action': 'ACCESS_GRANTED_sex,bmi,systolic_bp,diastolic_bp,hypertension,diagnosis,diagnosis_enc,patient_id,age_group', 'status': 'granted'}\n",
      "{'time': '2025-11-29T10:27:03', 'user': 'bob_doctor', 'role': 'doctor', 'action': 'ACCESS_GRANTED_patient_id,age_group,bmi,systolic_bp,diastolic_bp,hypertension,diagnosis', 'status': 'granted'}\n",
      "{'time': '2025-11-29T10:27:03', 'user': 'carol_analyst', 'role': 'analyst', 'action': 'ACCESS_GRANTED_age_group,bmi,systolic_bp,diastolic_bp,hypertension', 'status': 'granted'}\n"
     ]
    }
   ],
   "source": [
    "# ============================================\n",
    "# ETAP 4: KONTROLA DOSTĘPU I AUDYT\n",
    "# ============================================\n",
    "\n",
    "# Prosty model RBAC – Role-Based Access Control\n",
    "ROLES = {\n",
    "    \"admin\": {\n",
    "        \"columns\": df_anonym.columns.tolist()  # pełny dostęp\n",
    "    },\n",
    "    \"doctor\": {\n",
    "        # dostęp do cech klinicznych + diagnosis (ale np. bez view na zaszyfrowaną kolumnę)\n",
    "        \"columns\": [\"patient_id\", \"age_group\", \"bmi\",\n",
    "                    \"systolic_bp\", \"diastolic_bp\", \"hypertension\", \"diagnosis\"]\n",
    "    },\n",
    "    \"analyst\": {\n",
    "        # analityk widzi tylko dane zanonimizowane bez diagnosis\n",
    "        \"columns\": [\"age_group\", \"bmi\", \"systolic_bp\", \"diastolic_bp\", \"hypertension\"]\n",
    "    }\n",
    "}\n",
    "\n",
    "# Prosty dziennik audytu (log w pamięci)\n",
    "audit_log = []\n",
    "\n",
    "def audit(user: str, role: str, action: str, status: str):\n",
    "    \"\"\"Zapisuje wpis w logu audytowym.\"\"\"\n",
    "    audit_log.append({\n",
    "        \"time\": datetime.now().isoformat(timespec=\"seconds\"),\n",
    "        \"user\": user,\n",
    "        \"role\": role,\n",
    "        \"action\": action,\n",
    "        \"status\": status\n",
    "    })\n",
    "\n",
    "\n",
    "def get_data_view(df_in: pd.DataFrame, role: str, user: str = \"unknown\") -> pd.DataFrame:\n",
    "    \"\"\"Zwraca widok danych zgodny z rolą użytkownika, z logowaniem audytu.\"\"\"\n",
    "    if role not in ROLES:\n",
    "        audit(user, role, \"ACCESS_DENIED_UNKNOWN_ROLE\", \"denied\")\n",
    "        raise ValueError(f\"Nieznana rola: {role}\")\n",
    "\n",
    "    allowed_cols = [c for c in ROLES[role][\"columns\"] if c in df_in.columns]\n",
    "    view = df_in[allowed_cols].copy()\n",
    "    audit(user, role, f\"ACCESS_GRANTED_{','.join(allowed_cols)}\", \"granted\")\n",
    "    return view\n",
    "\n",
    "# Przykłady użycia:\n",
    "print(\"\\n[Etap 4] Przykładowe widoki danych dla różnych ról:\")\n",
    "\n",
    "df_admin_view = get_data_view(df_anonym, role=\"admin\", user=\"alice_admin\")\n",
    "print(\"\\nRola admin (pierwsze 3 wiersze):\")\n",
    "print(df_admin_view.head(3))\n",
    "\n",
    "df_doctor_view = get_data_view(df_anonym, role=\"doctor\", user=\"bob_doctor\")\n",
    "print(\"\\nRola doctor (pierwsze 3 wiersze):\")\n",
    "print(df_doctor_view.head(3))\n",
    "\n",
    "df_analyst_view = get_data_view(df_anonym, role=\"analyst\", user=\"carol_analyst\")\n",
    "print(\"\\nRola analyst (pierwsze 3 wiersze):\")\n",
    "print(df_analyst_view.head(3))\n",
    "\n",
    "print(\"\\n[Etap 4] Log audytu:\")\n",
    "for entry in audit_log:\n",
    "    print(entry)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "a6f64942-ac68-4022-88d3-53064094c01e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "[Etap 5.1] Weryfikacja integralności przed trenowaniem modelu:\n",
      "Integralność OK? True\n",
      "\n",
      "[Etap 5.2] Walidacja przykładowych wierszy:\n",
      "0 => True\n",
      "1 => True\n",
      "2 => True\n",
      "\n",
      "[Etap 5.3] Bezpieczne trenowanie modelu\n",
      "Accuracy (train): 0.9733333333333334\n",
      "Accuracy (test):  0.96\n",
      "\n",
      "[Etap 5.4] Bezpieczna predykcja dla wybranego pacjenta:\n",
      "Pacjent 0 -> predykcja: 1 prawdopodobieństwo HT: 1.0\n"
     ]
    }
   ],
   "source": [
    "# ============================================\n",
    "# ETAP 5: BEZPIECZEŃSTWO MODELU SI\n",
    "#  - weryfikacja integralności danych\n",
    "#  - walidacja wejścia\n",
    "#  - (prosty przykład trenowania i predykcji)\n",
    "# ============================================\n",
    "\n",
    "# --- 5.1 Definiujemy hash referencyjny danych treningowych ---\n",
    "\n",
    "TRAIN_HASH = original_hash  # w prawdziwym systemie zapisujemy to np. w konfiguracji lub bazie\n",
    "\n",
    "def verify_data_integrity(path: str, expected_hash: str) -> bool:\n",
    "    \"\"\"Sprawdza, czy plik z danymi nie został zmodyfikowany.\"\"\"\n",
    "    current_hash = compute_file_hash(path, \"sha256\")\n",
    "    return current_hash == expected_hash\n",
    "\n",
    "print(\"\\n[Etap 5.1] Weryfikacja integralności przed trenowaniem modelu:\")\n",
    "print(\"Integralność OK?\" , verify_data_integrity(PATH, TRAIN_HASH))\n",
    "\n",
    "# --- 5.2 Walidacja wejścia dla modelu ---\n",
    "\n",
    "ALLOWED_AGE_GROUPS = [\"<30\", \"30-49\", \"50-69\", \">=70\"]\n",
    "\n",
    "def validate_input_row(row: pd.Series) -> bool:\n",
    "    \"\"\"Prosta walidacja wejścia: zakresy, wartości dozwolone.\"\"\"\n",
    "    try:\n",
    "        if row[\"age_group\"] not in ALLOWED_AGE_GROUPS:\n",
    "            return False\n",
    "        if not (10 <= row[\"bmi\"] <= 60):\n",
    "            return False\n",
    "        if not (60 <= row[\"systolic_bp\"] <= 260):\n",
    "            return False\n",
    "        if not (40 <= row[\"diastolic_bp\"] <= 150):\n",
    "            return False\n",
    "    except KeyError:\n",
    "        return False\n",
    "    return True\n",
    "\n",
    "print(\"\\n[Etap 5.2] Walidacja przykładowych wierszy:\")\n",
    "for i in range(3):\n",
    "    print(i, \"=>\", validate_input_row(df_anonym.iloc[i]))\n",
    "\n",
    "\n",
    "# --- 5.3 Przygotowanie danych do modelu (poprawiona wersja) ---\n",
    "\n",
    "df_model = df_anonym.copy()\n",
    "\n",
    "# Kodowanie zmiennych kategorycznych: age_group + sex\n",
    "df_model = pd.get_dummies(df_model, columns=[\"age_group\", \"sex\"], drop_first=True)\n",
    "\n",
    "X = df_model.drop(columns=[\n",
    "    \"hypertension\", \n",
    "    \"diagnosis\", \n",
    "    \"diagnosis_enc\",\n",
    "    \"patient_id\"\n",
    "], errors=\"ignore\")\n",
    "\n",
    "y = df_model[\"hypertension\"]\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(\n",
    "    X, y, test_size=0.25, random_state=42, stratify=y\n",
    ")\n",
    "\n",
    "model = LogisticRegression(max_iter=1000)\n",
    "model.fit(X_train, y_train)\n",
    "\n",
    "print(\"\\n[Etap 5.3] Bezpieczne trenowanie modelu\")\n",
    "\n",
    "print(\"Accuracy (train):\", model.score(X_train, y_train))\n",
    "print(\"Accuracy (test): \", model.score(X_test, y_test))\n",
    "\n",
    "\n",
    "# --- 5.4 Bezpieczna funkcja predykcji ---\n",
    "\n",
    "def secure_predict(model, row: pd.Series, data_path: str, expected_hash: str):\n",
    "    \"\"\"\n",
    "    Bezpieczna inferencja:\n",
    "      1. weryfikujemy integralność pliku z danymi,\n",
    "      2. walidujemy wejście,\n",
    "      3. wykonujemy predykcję.\n",
    "    \"\"\"\n",
    "    # 1. integralność\n",
    "    if not verify_data_integrity(data_path, expected_hash):\n",
    "        raise RuntimeError(\"Dane zostały zmodyfikowane – przerwij predykcję!\")\n",
    "\n",
    "    # 2. walidacja wejścia\n",
    "    if not validate_input_row(row):\n",
    "        raise ValueError(\"Nieprawidłowe dane wejściowe – odrzucono wiersz.\")\n",
    "\n",
    "    # 3. przygotowanie cech (tak jak przy trenowaniu)\n",
    "    row_df = row.to_frame().T\n",
    "    row_df = pd.get_dummies(row_df, columns=[\"age_group\"], drop_first=True)\n",
    "    \n",
    "    # upewniamy się, że kolumny są zgodne z X_train\n",
    "    for col in X_train.columns:\n",
    "        if col not in row_df.columns:\n",
    "            row_df[col] = 0\n",
    "    row_df = row_df[X_train.columns]\n",
    "\n",
    "    proba = model.predict_proba(row_df)[0,1]\n",
    "    pred = model.predict(row_df)[0]\n",
    "    return pred, proba\n",
    "\n",
    "print(\"\\n[Etap 5.4] Bezpieczna predykcja dla wybranego pacjenta:\")\n",
    "\n",
    "sample_row = df_anonym.iloc[0]\n",
    "pred, proba = secure_predict(model, sample_row, PATH, TRAIN_HASH)\n",
    "print(\"Pacjent 0 -> predykcja:\", pred, \"prawdopodobieństwo HT:\", round(proba, 3))\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
